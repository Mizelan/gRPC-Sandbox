// options.go
package main

import (
	protov1 "fieldoption-codegen/gen/proto/v1"
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"strings"
)

// 필드 메타데이터를 저장하는 구조체
type fieldMetadata struct {
	dbColumn   string
	primaryKey bool
	index      bool
	dbType     string
}

func getFieldMetadata(field *protogen.Field) fieldMetadata {
	var metadata fieldMetadata

	// 기본 데이터베이스 타입 매핑
	dbType := getDefaultDBType(field)

	opts := field.Desc.Options()
	if opts != nil {
		// 컬럼명 옵션
		if val, ok := proto.GetExtension(opts, protov1.E_DbColumn).(string); ok && val != "" {
			metadata.dbColumn = val
		}

		// 기본키 옵션
		if val, ok := proto.GetExtension(opts, protov1.E_PrimaryKey).(bool); ok {
			metadata.primaryKey = val
		}

		// 인덱스 옵션
		if val, ok := proto.GetExtension(opts, protov1.E_Index).(bool); ok {
			metadata.index = val
		}

		// 데이터베이스 타입 옵션
		if val, ok := proto.GetExtension(opts, protov1.E_DbType).(string); ok && val != "" {
			dbType = val
		}
	}

	// 컬럼명이 지정되지 않은 경우 필드명을 스네이크 케이스로 변환하여 사용
	if metadata.dbColumn == "" {
		metadata.dbColumn = toSnakeCase(string(field.Desc.Name()))
	}

	metadata.dbType = dbType
	return metadata
}

func getDefaultDBType(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		return "TEXT"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "INTEGER"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "BIGINT"
	case protoreflect.FloatKind:
		return "REAL"
	case protoreflect.DoubleKind:
		return "DOUBLE PRECISION"
	case protoreflect.BoolKind:
		return "BOOLEAN"
	case protoreflect.BytesKind:
		return "BYTEA"
	default:
		return "TEXT"
	}
}

func toSnakeCase(s string) string {
	var result string
	for i, r := range s {
		if 'A' <= r && r <= 'Z' {
			if i > 0 {
				result += "_"
			}
			result += string(r - 'A' + 'a')
		} else {
			result += string(r)
		}
	}
	return result
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".db.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// 파일 헤더와 임포트 구문 생성
	g.P("// Code generated by protoc-gen-db. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`    "context"`)
	g.P(`    "database/sql"`)
	g.P(`    "strings"`)
	g.P(")")
	g.P()

	// 각 메시지 타입에 대한 코드 생성
	for _, message := range file.Messages {
		generateMessageCode(g, message)
	}
}

// 메시지 타입별 코드 생성
func generateMessageCode(g *protogen.GeneratedFile, message *protogen.Message) {
	tableName := toSnakeCase(string(message.Desc.Name()))
	generateCreateTableMethod(g, message, tableName)
	generateInsertMethod(g, message, tableName)
	generateUpdateMethod(g, message, tableName)
	generateDeleteMethod(g, message, tableName)
	generateSelectMethods(g, message, tableName)
}

// 테이블 생성 SQL 메서드 생성
func generateCreateTableMethod(g *protogen.GeneratedFile, message *protogen.Message, tableName string) {
	g.P("func (m *", message.GoIdent, ") CreateTableSQL() string {")
	g.P("    var statements []string")
	g.P("    statements = append(statements, `CREATE TABLE IF NOT EXISTS ", tableName, " (`)")

	var columns []string
	var indexes []string

	for _, field := range message.Fields {
		metadata := getFieldMetadata(field)
		column := fmt.Sprintf("    %s %s", metadata.dbColumn, metadata.dbType)
		if metadata.primaryKey {
			column += " PRIMARY KEY"
		}
		columns = append(columns, column)

		if metadata.index {
			indexName := fmt.Sprintf("idx_%s_%s", tableName, metadata.dbColumn)
			indexes = append(indexes, fmt.Sprintf("CREATE INDEX IF NOT EXISTS %s ON %s(%s)",
				indexName, tableName, metadata.dbColumn))
		}
	}

	g.P("    statements = append(statements, `", strings.Join(columns, ",\n"), "`)")
	g.P("    statements = append(statements, `)`)")

	for _, idx := range indexes {
		g.P("    statements = append(statements, `", idx, "`)")
	}

	g.P("    return strings.Join(statements, \";\")")
	g.P("}")
	g.P()
}

// Insert 메서드 생성
func generateInsertMethod(g *protogen.GeneratedFile, message *protogen.Message, tableName string) {
	g.P("func (m *", message.GoIdent, ") Insert(ctx context.Context, db *sql.DB) error {")

	var columns []string
	var placeholders []string
	var values []string

	for i, field := range message.Fields {
		metadata := getFieldMetadata(field)
		columns = append(columns, metadata.dbColumn)
		placeholders = append(placeholders, fmt.Sprintf("$%d", i+1))
		values = append(values, "m."+field.GoName)
	}

	g.P("    query := `INSERT INTO ", tableName, " (")
	g.P("        ", strings.Join(columns, ", "))
	g.P("    ) VALUES (", strings.Join(placeholders, ", "), ")`")
	g.P()
	g.P("    _, err := db.ExecContext(ctx, query, ", strings.Join(values, ", "), ")")
	g.P("    return err")
	g.P("}")
	g.P()
}

// Update 메서드 생성
func generateUpdateMethod(g *protogen.GeneratedFile, message *protogen.Message, tableName string) {
	g.P("func (m *", message.GoIdent, ") Update(ctx context.Context, db *sql.DB) error {")

	var sets []string
	var values []string
	var pkColumn string
	var pkValue string

	for i, field := range message.Fields {
		metadata := getFieldMetadata(field)
		if metadata.primaryKey {
			pkColumn = metadata.dbColumn
			pkValue = "m." + field.GoName
			continue
		}
		sets = append(sets, fmt.Sprintf("%s = $%d", metadata.dbColumn, i+1))
		values = append(values, "m."+field.GoName)
	}

	values = append(values, pkValue)

	g.P("    query := `UPDATE ", tableName, " SET")
	g.P("        ", strings.Join(sets, ",\n        "))
	g.P("    WHERE ", pkColumn, " = $", len(values), "`")
	g.P()
	g.P("    _, err := db.ExecContext(ctx, query, ", strings.Join(values, ", "), ")")
	g.P("    return err")
	g.P("}")
	g.P()
}

// Delete 메서드 생성
func generateDeleteMethod(g *protogen.GeneratedFile, message *protogen.Message, tableName string) {
	g.P("func (m *", message.GoIdent, ") Delete(ctx context.Context, db *sql.DB) error {")

	var pkColumn string
	var pkValue string
	for _, field := range message.Fields {
		metadata := getFieldMetadata(field)
		if metadata.primaryKey {
			pkColumn = metadata.dbColumn
			pkValue = "m." + field.GoName
			break
		}
	}

	g.P("    query := `DELETE FROM ", tableName, " WHERE ", pkColumn, " = $1`")
	g.P("    _, err := db.ExecContext(ctx, query, ", pkValue, ")")
	g.P("    return err")
	g.P("}")
	g.P()
}

// Select 메서드들 생성
func generateSelectMethods(g *protogen.GeneratedFile, message *protogen.Message, tableName string) {
	var columns []string
	var scanVars []string
	var pkColumn string

	for _, field := range message.Fields {
		metadata := getFieldMetadata(field)
		columns = append(columns, metadata.dbColumn)
		scanVars = append(scanVars, "&m."+field.GoName)
		if metadata.primaryKey {
			pkColumn = metadata.dbColumn
		}
	}

	// GetByPK 메서드
	g.P("func Get", message.GoIdent, "ByPK(ctx context.Context, db *sql.DB, pk any) (*", message.GoIdent, ", error) {")
	g.P("    m := &", message.GoIdent, "{}")
	g.P("    query := `SELECT")
	g.P("        ", strings.Join(columns, ",\n        "))
	g.P("    FROM ", tableName)
	g.P("    WHERE ", pkColumn, " = $1`")
	g.P()
	g.P("    err := db.QueryRowContext(ctx, query, pk).Scan(", strings.Join(scanVars, ", "), ")")
	g.P("    if err != nil {")
	g.P("        return nil, err")
	g.P("    }")
	g.P("    return m, nil")
	g.P("}")
	g.P()

	// List 메서드
	g.P("func List", message.GoIdent, "s(ctx context.Context, db *sql.DB, limit, offset int) ([]*", message.GoIdent, ", error) {")
	g.P("    query := `SELECT")
	g.P("        ", strings.Join(columns, ",\n        "))
	g.P("    FROM ", tableName)
	g.P("    LIMIT $1 OFFSET $2`")
	g.P()
	g.P("    rows, err := db.QueryContext(ctx, query, limit, offset)")
	g.P("    if err != nil {")
	g.P("        return nil, err")
	g.P("    }")
	g.P("    defer rows.Close()")
	g.P()
	g.P("    var results []*", message.GoIdent)
	g.P("    for rows.Next() {")
	g.P("        m := &", message.GoIdent, "{}")
	g.P("        if err := rows.Scan(", strings.Join(scanVars, ", "), "); err != nil {")
	g.P("            return nil, err")
	g.P("        }")
	g.P("        results = append(results, m)")
	g.P("    }")
	g.P("    return results, rows.Err()")
	g.P("}")
	g.P()
}

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			generateFile(gen, f)
		}
		return nil
	})
}
